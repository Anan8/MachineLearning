############################################################################
# LGPL License                                                             #
#                                                                          #
# This file is part of the Machine Learning Framework.                     #
# Copyright (c) 2010-2012, Philipp Kraus, <philipp.kraus@flashpixx.de>     #
# This program is free software: you can redistribute it and/or modify     #
# it under the terms of the GNU Lesser General Public License as           #
# published by the Free Software Foundation, either version 3 of the       #
# License, or (at your option) any later version.                          #
#                                                                          #
# This program is distributed in the hope that it will be useful,          #
# but WITHOUT ANY WARRANTY; without even the implied warranty of           #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
# GNU Lesser General Public License for more details.                      #
#                                                                          #
# You should have received a copy of the GNU Lesser General Public License #
# along with this program. If not, see <http://www.gnu.org/licenses/>.     #
############################################################################
 
# -*- coding: utf-8 -*-

import os
import re
import urllib2
Import("*")

workingpath = os.path.abspath(os.curdir)


#=== download packages ===============================================================================================================
def Boost_DownloadURL()  :
    # read download path of the Boost (latest version)
    f = urllib2.urlopen("http://www.boost.org/users/download/")
    html = f.read()
    f.close()
    
    found = re.search("<a href=\"http://sourceforge.net/projects/boost/files/(.*)\">Download</a>", html)
    if found == None :
        raise RuntimeError("Boost Download URL not found")
        
    downloadurl = found.group(0)
    downloadurl = downloadurl.replace("<a href=\"", "")
    downloadurl = downloadurl.replace("\">Download</a>", "")
    
    version     = found.group(1).replace("boost", "")
    version     = version.replace("/", "")
    
    
    # read url of the tar.gz
    f = urllib2.urlopen(downloadurl)
    html = f.read()
    f.close()

    found = re.search("<a href=\"http://sourceforge.net/projects/boost/files/boost(.*).tar.gz/download", html)
    if found == None :
        raise RuntimeError("Boost Download URL not found")

    downloadurl = found.group(0)
    downloadurl = downloadurl.replace("<a href=\"", "")
   
    return downloadurl, "boost-" + version + ".tar.gz"
    
    
    
def JsonCPP_DownloadURL() :
    # read download path of the JsonCPP library (latest version)
    f = urllib2.urlopen("http://sourceforge.net/projects/jsoncpp/")
    html = f.read()
    f.close()
    
    found = re.search("<a href=\"/projects/jsoncpp/files/latest/download\" title=\"Download /jsoncpp/(.*)/jsoncpp-src-(.*)\.tar\.gz", html)
    if found == None :
        raise RuntimeError("JsonCPP Download URL not found")

    return "http://sourceforge.net/projects/jsoncpp/files/latest/download", "jsoncpp-src-" + found.group(1) + ".tar.gz"
    
   
     
def LibXML2_DownloadURL() :
    # read latest release version of LibXML (latest version under ftp://xmlsoft.org/libxml2/LATEST_LIBXML2 )
    f = urllib2.urlopen("http://xmlsoft.org/news.html")
    html = f.read()
    f.close()
    
    found = re.search("<h3>\d.\d.\d:(.*)</h3>", html)
    if found == None :
        raise RuntimeError("LibXML release version number not found")
    
    version = found.group(0).replace("<", "").replace(">", "").replace("h3", "")     
    version = re.sub(":(.*)", "", version)
    
    return "ftp://xmlsoft.org/libxml2/libxml2-"+version+".tar.gz", "libxml2-"+version+".tar.gz"



def HDF5_DownloadURL() :
    # read download path of the HDF library (latest version)
    f = urllib2.urlopen("http://www.hdfgroup.org/ftp/HDF5/current/src/")
    html = f.read()
    f.close()
    
    found = re.search("<a href=\"(.*)tar.gz\">", html)
    if found == None :
        raise RuntimeError("HDF Download URL not found")
    
    filename = found.group(0).replace("<a href=\"./", "").replace("\">", "")

    return "http://www.hdfgroup.org/ftp/HDF5/current/src/"+filename, filename



def LaPack_DownloadURL() :
    # read download path of the LAPack (latest version)
    f = urllib2.urlopen("http://www.netlib.org/lapack/")
    html = f.read()
    f.close()
    
    found = re.search("<a href=\"http://www.netlib.org/lapack/(.*)tgz\">", html)
    if found == None :
        raise RuntimeError("LAPack Download URL not found")
        
    downloadurl = found.group(0).replace("<a href=\"", "").replace("\">", "")
    filename    = downloadurl.replace("http://www.netlib.org/lapack/", "")
    
    return downloadurl, filename


def Atlas_DownloadURL() :
    # read download path of the LAPack (latest version)
    f = urllib2.urlopen("http://sourceforge.net/projects/math-atlas/")
    html = f.read()
    f.close()
    
    found = re.search("<small title=\"(.*)\">(.*)</small>", html)
    if found == None :
        raise RuntimeError("Atlas Download URL not found")

    return "http://sourceforge.net/projects/math-atlas/files/latest/download?source=files", found.group(2)
    
    
def CLN_DownloadURL() :
    # read download path of the CLN (latest version)
    f = urllib2.urlopen("http://www.ginac.de/CLN/")
    html = f.read()
    f.close()
    
    found = re.search("<a href=\"cln-(.*)\.tar\.bz2\">", html)
    if found == None :
        raise RuntimeError("CLN Download URL not found")
        
    filename    = "cln-" + found.group(1) + ".tar.bz2"

    return "http://www.ginac.de/CLN/"+filename, filename
    
    
def Ginac_DownloadURL() :
    # read download path of the CLN (latest version)
    f = urllib2.urlopen("http://www.ginac.de/Download.html")
    html = f.read()
    f.close()
    
    found = re.search("<a href=\"http://www.ginac.de/ginac-(.*)\.tar\.bz2\">", html)
    if found == None :
        raise RuntimeError("GiNaC Download URL not found")

    filename = "ginac-" + found.group(1) + ".tar.bz2"

    return "http://www.ginac.de/"+filename, filename
    
    
def GZip_DownloadURL() :
    # read download path of the ZLib (latest version)
    f = urllib2.urlopen("http://www.zlib.net/")
    html = f.read()
    f.close()
    
    found = re.search("http://zlib.net/zlib-(.*)\.tar\.gz", html)
    if found == None :
        raise RuntimeError("ZLib Download URL not found")

    filename = "zlib-" + found.group(1) + ".tar.gz"

    return "http://zlib.net/"+filename, filename

    
def BZip2_DownloadURL() :
    # read download path of the BZip2 (latest version)
    f = urllib2.urlopen("http://www.bzip.org/downloads.html")
    html = f.read()
    f.close()
    
    found = re.search("<a href=\"/(.*)/bzip2-(.*)\.tar\.gz\">", html)
    if found == None :
        raise RuntimeError("BZip2 Download URL not found")
        
    version = found.group(1)
        
    return "http://www.bzip.org/"+version+"/bzip2-"+version+".tar.gz", "bzip2-"+version+".tar.gz"



#=== building libraries ==============================================================================================================
def Boost_BuildInstall(env, source, gzipbuild, bzipbuild)  :
    # extract path and version of the source name
    boostpath   = str(source).replace("['", "").replace("']", "")
    version     = boostpath.replace("boost-", "")
    boostpath   = os.path.join(workingpath, boostpath.replace(".", "_").replace("-", "_"))

    # set the toolset and compile the bjam and build boost
    boostoptions = "--with-exception --with-filesystem --with-math --with-random --with-regex --with-date_time --with-thread --with-system --with-program_options --with-serialization --with-iostreams --disable-filesystem2 link=shared runtime-link=shared threading=multi variant=%V% install --layout=system --prefix="+os.path.abspath(os.path.join(workingpath, "build_"+env["buildtype"], "boost", version))
    boostoptions = boostoptions.replace("%V%", env["buildtype"])
    if env["withmpi"] :
        boostoptions = "--with-mpi " + boostoptions
    
    cmd = None
    if env["TOOLKIT"] in ["darwin", "posix", "cygwin"] :
        cmd = "cd " + boostpath + ";"
        if env["withmpi"] :
            cmd = cmd + " echo \"using mpi ;\" >> " + os.path.join(boostpath, "tools", "build", "v2", "user-config.jam") + ";"
        cmd = cmd + " ./bootstrap.sh; ./b2 " + boostoptions
    
    else :
        raise RuntimeError("toolkit not known")

    # build Boost with Bzip2 and ZLib support and set the dependency
    dependency = [source]
    if (gzipbuild <> None) and (bzipbuild <> None) :
        dependency.append(gzipbuild)
        dependency.append(bzipbuild)
        
        gzipversion = str(gzipbuild).replace("['", "").replace("']", "").replace("buildgzip-", "")
        bzipversion = str(bzipbuild).replace("['", "").replace("']", "").replace("buildbzip2-", "")
        zipcmd   = "export BZIP2_BINARY=bz2; export ZLIB_BINARY=z; "
        zipcmd  += "export ZLIB_INCLUDE="+os.path.join(workingpath, "build_"+env["buildtype"], "zlib", gzipversion, "include")+"; "
        zipcmd  += "export ZLIB_LIBPATH="+os.path.join(workingpath, "build_"+env["buildtype"], "zlib", gzipversion, "lib")+"; "
        zipcmd  += "export BZIP2_INCLUDE="+os.path.join(workingpath, "build_"+env["buildtype"], "bzip2", bzipversion, "include")+"; "
        zipcmd  += "export BZIP2_LIBPATH="+os.path.join(workingpath, "build_"+env["buildtype"], "bzip2", bzipversion, "lib")+"; "
        cmd      = zipcmd + cmd
        
    return env.Command("buildboost-"+version, dependency, cmd)
      
      
def Gzip_BuildInstall(env, extract) :
    version = str(extract).replace("['", "").replace("']", "").replace("zlib-", "")
    return env.Command("buildgzip-"+version, extract, "cd $SOURCE; ./configure --prefix="+os.path.abspath(os.path.join(workingpath, "build_"+env["buildtype"], "zlib", version))+"; make; make install")
   
   
def BZip2_BuildInstall(env, extract) :
    version = str(extract).replace("['", "").replace("']", "").replace("bzip2-", "")
    return env.Command("buildbzip2-"+version, extract, "cd $SOURCE; make install PREFIX="+os.path.abspath(os.path.join(workingpath, "build_"+env["buildtype"], "bzip2", version)))
      
        
def JsonCPP_BuildInstall(env, targz, extract) :
    # extract version and build regex for getting files
    sourcepath = str(targz).replace(".tar.gz", "").replace("']", "").replace("['", "")
    version    = sourcepath.replace("jsoncpp-src-", "")
    regcpp     = re.compile("jsoncpp-src-(.*)src(.)lib_json(.*)\.cpp")
    regheader  = re.compile("jsoncpp-src-(.*)include(.*)\.h(.*)")
    
    # extract the needed source from the list
    libsrc      = []
    libheader   = []
    for i in extract :
        name = str(i)
        cpp  = regcpp.match( name ) 

        if cpp <> None :
            libsrc.append( i )
        header = regheader.match( name )
        if header <> None :
            libheader.append( i ) 

    envjson = env.Clone()
    envjson.Append(CPPPATH = os.path.join(sourcepath, "include"))
    
    libbuild = []
    if env["TOOLKIT"] in ["posix", "cygwin", "darwin"] :
        libbuild.append( envjson.Library(target="json", source=libsrc) )
        libbuild.append( envjson.SharedLibrary(target="json", source=libsrc) )
        
    else :
        raise RuntimeError("no library jsoncpp build target found in toolkit ["+env["TOOLKIT"]+"]")
        
    # install header and libraries
    libinstall      = env.Install( os.path.join(workingpath, "build_"+env["buildtype"], "jsoncpp", version, "lib"), libbuild )
    headerdir       = env.Command( os.path.join(workingpath, "build_"+env["buildtype"], "jsoncpp", version, "include", "json"), "", Mkdir("$TARGET"))
    headerinstall   = []
    for i in libheader :
        headerinstall.append( env.Command( os.path.join(str(headerdir).replace("']", "").replace("['", ""), os.path.basename(str(i))), i, Copy("$TARGET", "$SOURCE")) )
    
    # prevent libs and headers during clean
    env.NoClean(libinstall)
    env.NoClean(headerinstall)
    
    return libinstall + headerinstall


def Atlas_BuildInstall(env, atlasdir, lapacktargz) :
    # Atlas need a temporary build directory
    builddir = env.Command( str(atlasdir).replace("['", "").replace("']", "")+"-buildtmp", atlasdir, Mkdir("$TARGET"))
    version  = str(atlasdir).replace("atlas", "").replace("['", "").replace("']", "")
    
    cmd = "cd " + os.path.join(workingpath, str(builddir).replace("['", "").replace("']", "")) + "; ../ATLAS/configure --dylibs"
    if env["atlaspointerwidth"] == "32" :
        cmd += " -b 32"
    elif env["atlaspointerwidth"] == "64" :
        cmd += " -b 64"
    cmd += " --with-netlib-lapack-tarfile=../" + str(lapacktargz).replace("['", "").replace("']", "") + " --prefix=" + os.path.join(workingpath, "build_"+env["buildtype"], "atlas", version) + "; make; make install"
    
    return env.Command("buildatlas-"+version, [atlasdir, lapacktargz, builddir], cmd)


def HDF5_BuildInstall(env, hdfdir) :
    version = str(hdfdir).replace("']", "").replace("['", "").replace("hdf5-", "")
    
    return env.Command("buildhdf5-"+version, hdfdir, "cd $SOURCE; ./configure --enable-cxx --prefix=" + os.path.join(workingpath, "build_"+env["buildtype"], "hdf", version) + "; make; make install")


def LibXML2_BuildInstall(env, libxmldir) :
    version = str(libxmldir).replace("']", "").replace("['", "").replace("libxml2-", "")
    
    return env.Command("buildlibxml2-"+version, libxmldir, "cd $SOURCE; ./configure --prefix="+os.path.abspath(os.path.join(workingpath, "build_"+env["buildtype"], "xml", version))+ "; make; make install")
    
        
def GiNaC_BuildInstall(env, ginacdir, clnbuild) :
    version    = str(ginacdir).replace("']", "").replace("['", "").replace("ginac-", "")
    clnversion = str(clnbuild).replace("']", "").replace("['", "").replace("buildcln-", "")
    clninclude = os.path.join(workingpath, "build_"+env["buildtype"], "cln", clnversion, "include")
    clnlib     = os.path.join(workingpath, "build_"+env["buildtype"], "cln", clnversion, "lib")
    
    return env.Command("buildginac-"+version, [ginacdir, clnbuild], "cd $SOURCE; export CLN_CFLAGS=-I" + clninclude + "; export CLN_LIBS=\"-L" + clnlib + " -lcln\"; ./configure --prefix="+os.path.abspath(os.path.join(workingpath, "build_"+env["buildtype"], "ginac", version))+ "; make; make install")
        
        
def CLN_BuildInstall(env, clndir) :
    version = str(clndir).replace("']", "").replace("['", "").replace("cln-", "")
    
    return env.Command("buildcln-"+version, clndir, "cd $SOURCE; ./configure --prefix="+os.path.abspath(os.path.join(workingpath, "build_"+env["buildtype"], "cln", version))+ "; make; make install")
    
    

"""
def build_boost(target, source, env)  :
    boostpath = glob.glob(os.path.join(workingpath, "boost_*"))
    if boostpath == None or not(boostpath) :
        raise RuntimeError("Boost Build Directory not found")

    boostpath     = boostpath[0]
    
    # extract the version part
    boostversion  = boostpath.replace(os.path.join(workingpath, "boost_"), "")
    boostversion  = boostversion.replace("_", ".")

    # for calling bootstrap.sh change the current work directory
    runsyscmd("cd "+boostpath+"; ./bootstrap.sh", env)
    
    # call the bjam command
    toolset = "gcc"
    if env["TOOLKIT"] == "darwin" :
        toolset = "darwin"
        
    # if MPI is set, compile Boost with MPI support
    mpi = ""
    if env["withmpi"] :
        oFile = open(os.path.join(boostpath, "tools", "build", "v2", "user-config.jam"), "a+")
        oFile.write("\n using mpi ;\n")
        oFile.close()
        mpi = "--with-mpi"
            
    # build the Boost (on Cygwin the path to BZip2 and ZLib ist set manually)
    zipprefix = ""
    if env["TOOLKIT"] == "cygwin" :
        zipprefix += "export BZIP2_BINARY=bz2; export ZLIB_BINARY=z; "
        
        zlibpath = glob.glob(os.path.join(workingpath, "build", "zlib", "*"))
        if zlibpath == None or not(zlibpath) :
            raise RuntimeError("ZLib Install Directory not found")
        zlibpath = zlibpath[0]
            
        zipprefix += "export ZLIB_INCLUDE="+os.path.abspath(os.path.join(zlibpath, "include"))+"; "
        zipprefix += "export ZLIB_LIBPATH="+os.path.abspath(os.path.join(zlibpath, "lib"))+"; "
        
        bzippath = glob.glob(os.path.join(workingpath, "build", "bzip2", "*"))
        if bzippath == None or not(bzippath) :
            raise RuntimeError("ZLib Install Directory not found")
        bzippath = bzippath[0]

        zipprefix += "export BZIP2_INCLUDE="+os.path.abspath(os.path.join(bzippath, "include"))+"; "
        zipprefix += "export BZIP2_LIBPATH="+os.path.abspath(os.path.join(bzippath, "lib"))+"; "
    
    runsyscmd(zipprefix+"cd "+boostpath+"; ./b2 "+mpi+" --with-exception --with-filesystem --with-math --with-random --with-regex --with-date_time --with-thread --with-system --with-program_options --with-serialization --with-iostreams --disable-filesystem2 threading=multi link=shared runtime-link=shared variant=release toolset="+toolset+" install --prefix="+os.path.abspath(os.path.join(workingpath, "build", "boost", boostversion)), env)

    # checkout the numerical binding
    runsyscmd("svn checkout http://svn.boost.org/svn/boost/sandbox/numeric_bindings/ "+os.path.join(workingpath, "build", "boost", "sandbox", "numeric_bindings"), env )

    return []
    
    
def build_zlib(target, source, env) :
    zlibpath = glob.glob(os.path.join(workingpath, "zlib-*"))
    if zlibpath == None or not(zlibpath) :
        raise RuntimeError("ZLib Build Directory not found")

    zlibpath     = zlibpath[0]
    zlibversion  = zlibpath.replace(os.path.join(workingpath, "zlib-"), "")

    # the "make install" creates problems under Cygwin so do it manually
    runsyscmd( "cd "+zlibpath+"; ./configure --prefix="+os.path.abspath(os.path.join(workingpath, "build", "zlib", zlibversion))+ "; make", env )
    
    # do install and copy headerfiles
    os.system( "cd "+zlibpath+"; make install" )
    
    try :
        os.makedirs(os.path.join(workingpath, "build", "zlib", zlibversion, "include"))
    except :
        pass
    try :
        headerfiles = glob.glob(os.path.join(zlibpath, "*.h"))
        for i in headerfiles :
            shutil.copyfile(i, os.path.join(workingpath, "build", "zlib", zlibversion, "include", os.path.basename(i)))
    except :
        pass
    return []
    

def build_bzip2(target, source, env) :
    bzippath = glob.glob(os.path.join(workingpath, "bzip2-*"))
    if bzippath == None or not(bzippath) :
        raise RuntimeError("BZip2 Build Directory not found")

    bzippath     = bzippath[0]
    bzipversion  = bzippath.replace(os.path.join(workingpath, "bzip2-"), "")

    runsyscmd( "cd "+bzippath+"; make; make install PREFIX="+os.path.abspath(os.path.join(workingpath, "build", "bzip2", bzipversion)), env )
    return []
    
def build_ginaccln(target, source, env) :
    clnpath = glob.glob(os.path.join(workingpath, "cln-*"))
    if clnpath == None or not(clnpath) :
        raise RuntimeError("CLN Build Directory not found")
    
    clnpath     = clnpath[0]
    clnversion  = clnpath.replace(os.path.join(workingpath, "cln-"), "")
    
    ginacpath = glob.glob(os.path.join(workingpath, "ginac-*"))
    if ginacpath == None or not(ginacpath) :
        raise RuntimeError("GiNaC Build Directory not found")
    
    ginacpath     = ginacpath[0]
    ginacversion  = ginacpath.replace(os.path.join(workingpath, "ginac-"), "")

    runsyscmd( "cd "+clnpath+"; ./configure --prefix="+os.path.abspath(os.path.join(workingpath, "build", "cln", clnversion))+ "; make; make install", env )
    runsyscmd( "cd "+ginacpath+"; export CLN_CFLAGS=-I"+os.path.abspath(os.path.join(workingpath, "build", "cln", clnversion, "include"))+"; export CLN_LIBS=\"-L"+os.path.abspath(os.path.join(workingpath, "build", "cln", clnversion, "lib"))+" -lcln\"; ./configure --prefix="+os.path.abspath(os.path.join(workingpath, "build", "ginac", ginacversion))+ "; make; make install", env )
    return []

"""



#=== configuration ===================================================================================================================
"""
def showconfig(target, source, env) :
    #detect built packages and shows PATH, CPPPATH, LIBRARY_PATH for installation
    includes = glob.glob(os.path.join(workingpath, "build", "**", "**", "include"))
    
    #replace "install/build" to "<installation dir>"
    cpppath = []
    for i in includes :
        cpppath.append( os.path.join("<installation dir>", os.path.sep.join(i.split(os.path.sep)[2:])) )
        
    # detect Boost Numeric Bindings
    if os.path.isdir( os.path.join("install", "build", "boost", "sandbox", "numeric_bindings") ) :
        cpppath.append( os.path.join("<installation dir>", "boost", "sandbox", "numeric_bindings") )
        
        
    libs = glob.glob(os.path.join(workingpath, "build", "**", "**", "lib"))
    libpath = []
    for i in libs :
        libpath.append( os.path.join("<installation dir>", os.path.sep.join(i.split(os.path.sep)[2:])) )
    
    # on Cygwin some "bin" directories must be added to the library path
    if env["TOOLKIT"] == "cygwin" :
        libs = glob.glob(os.path.join(workingpath, "build", "**", "**", "bin"))
        for i in libs :
            path = i.split(os.path.sep)[2:];
            if path[0] == "boost" or path[0] == "xml2" :
                libpath.append( os.path.join("<installation dir>", os.path.sep.join(path)) )
    
        
    print colorama.Style.BRIGHT
    print "-------------------------------------------------------------------------------------"
    print "Warning: move the library/build directory outside of the framework directory,"
    print "because the a clean target remove the compiled libraries."
    print ""
    print "Add the following variables / content to your environment and replace"
    print "<installation dir> to the directory path that stores the build directory"
    print ""
    print "CPPPATH="+os.pathsep.join(cpppath)
    print ""
    
    if env["TOOLKIT"] == "cygwin" :
        print "PATH="+os.pathsep.join(libpath)
        print ""
        print "add also Cygwin bin directory to the path for using compiled program outside of Cygwin"
        
    elif env["TOOLKIT"] == "posix" :
        print "LD_LIBRARY_PATH="+os.pathsep.join(libpath)
    
    elif env["TOOLKIT"] == "darwin" :
        print "LIBRARY_PATH="+os.pathsep.join(libpath)
        print ""
        print "it is recommand to add the following line to your /etc/profile or ~/.profile"
        print "export DYLD_LIBRARY_PATH=$LIBRARY_PATH"
    
    print "-------------------------------------------------------------------------------------" 
    print colorama.Style.RESET_ALL
    return []
"""
    

#=== target structure ================================================================================================================
def FinishMessage_print(s, target, source, env):
    pass
def FinishMessage(target, source, env) :
    alias = str(target[0])
    if alias == "librarydownload" :
        print "\n==> library sources have been downloaded, run for building the target [librarybuild]\n"
    if alias == "librarybuild" :
        print "\n==> libraries have been built and stored under [library"+os.path.sep+"build]\n"
    
    

skiplist = str(env["skiplibrary"]).split(",")
if (("librarybuild" in COMMAND_LINE_TARGETS) or ("librarydownload" in COMMAND_LINE_TARGETS)) and ("all" in skiplist) :
    raise RuntimeError("nothing to build")

#build into seperate directory, check needed installation tools and get the command line for extracting tar.gz files
lstbuild    = []
lstdownload = []

# build target list
if ("librarybuild" in COMMAND_LINE_TARGETS) or ("librarydownload" in COMMAND_LINE_TARGETS) :

    # download Atlas & LaPack, extract & install
    if not("atlas" in skiplist) :
        lapacktargz = env.ParseAndDownload( LaPack_DownloadURL )
        atlastarbz  = env.ParseAndDownload( Atlas_DownloadURL )
        atlasdir    = env.Command(str(atlastarbz).replace("[", "").replace("]", "").replace("'", "").replace(".tar.bz2", ""), atlastarbz, env["EXTRACT_CMDBZ"]+env["extractsuffix"]+"library")
        lstdownload.append(lapacktargz)
        lstdownload.append(atlastarbz)
        lstbuild.append( Atlas_BuildInstall(env, atlasdir, lapacktargz) )

    # download Boost, extract & install
    if not("boost" in skiplist) :
        bzipbuild = None
        gzipbuild = None
        if env["zipsupport"] :
            gziptargz = env.ParseAndDownload( GZip_DownloadURL )
            bziptargz = env.ParseAndDownload( BZip2_DownloadURL )
            bzipbuild = BZip2_BuildInstall(env, env.Command(str(bziptargz).replace("[", "").replace("]", "").replace("'", "").replace(".tar.gz", ""), bziptargz, env["EXTRACT_CMD"]+env["extractsuffix"]+"library") )
            gzipbuild = Gzip_BuildInstall(env,  env.Command(str(gziptargz).replace("[", "").replace("]", "").replace("'", "").replace(".tar.gz", ""), gziptargz, env["EXTRACT_CMD"]+env["extractsuffix"]+"library") )
            lstdownload.append(gziptargz)
            lstdownload.append(bziptargz)
    
        boosttargz = env.ParseAndDownload( Boost_DownloadURL )
        boostdir   = env.Command(str(boosttargz).replace("[", "").replace("]", "").replace("'", "").replace(".tar.gz", ""), boosttargz, env["EXTRACT_CMD"]+env["extractsuffix"]+"library")
        boostbuild = Boost_BuildInstall(env, boostdir, gzipbuild, bzipbuild)
        
        lstbuild.append( env.Command("boostnumericbindings", boostbuild, "svn checkout http://svn.boost.org/svn/boost/sandbox/numeric_bindings/ "+os.path.join(workingpath, "build_"+env["buildtype"], "boost", "sandbox", "numeric_bindings")) )
        lstdownload.append(boosttargz)
        
        
    if not("ginac" in skiplist) :
        clntarbz   = env.ParseAndDownload( CLN_DownloadURL )
        ginactarbz = env.ParseAndDownload( Ginac_DownloadURL )
        clndir     = env.Command(str(clntarbz).replace("[", "").replace("]", "").replace("'", "").replace(".tar.bz2", ""), clntarbz, env["EXTRACT_CMDBZ"]+env["extractsuffix"]+"library")
        ginacdir   = env.Command(str(ginactarbz).replace("[", "").replace("]", "").replace("'", "").replace(".tar.bz2", ""), ginactarbz, env["EXTRACT_CMDBZ"]+env["extractsuffix"]+"library")
        lstdownload.append(clntarbz)
        lstdownload.append(ginactarbz)
        lstbuild.append( GiNaC_BuildInstall(env, ginacdir, CLN_BuildInstall(env, clndir)) )

    #download JSON library, extract & install
    if not("json" in skiplist) :
        jsontargz  = env.ParseAndDownload( JsonCPP_DownloadURL )
        jsonfiles  = env.Extract(str(jsontargz).replace("[", "").replace("]", "").replace("'", "").replace(".tar.gz", ""), jsontargz, extractsuffix=env["extractsuffix"]+"library")
        lstbuild.extend( JsonCPP_BuildInstall(env, jsontargz, jsonfiles) )
        lstdownload.append(jsontargz)
        
    # download HDF5, extract & install
    if not("hdf" in skiplist) :
        hdftargz = env.ParseAndDownload( HDF5_DownloadURL )
        hdfdir   = env.Command(str(hdftargz).replace("[", "").replace("]", "").replace("'", "").replace(".tar.gz", ""), hdftargz, env["EXTRACT_CMD"]+env["extractsuffix"]+"library")
        lstdownload.append(hdftargz)
        lstbuild.append( HDF5_BuildInstall(env, hdfdir) )
        
    # download LibXML, extract & install
    if not("xml" in skiplist) :
        xmltargz = env.ParseAndDownload( LibXML2_DownloadURL )
        xmldir   = env.Command(str(xmltargz).replace("[", "").replace("]", "").replace("'", "").replace(".tar.gz", ""), xmltargz, env["EXTRACT_CMD"]+env["extractsuffix"]+"library")
        lstdownload.append(xmltargz)
        lstbuild.append( LibXML2_BuildInstall(env, xmldir) )


env.Alias("librarydownload", lstdownload, FinishMessage, PRINT_CMD_LINE_FUNC=FinishMessage_print)
env.Clean(
    env.Alias("librarybuild", lstbuild, FinishMessage, PRINT_CMD_LINE_FUNC=FinishMessage_print), 
    [
        Glob(os.path.join("#", "library", "boost*")),
        Glob(os.path.join("#", "library", "bzip2*")),
        Glob(os.path.join("#", "library", "zlib*")),
        Glob(os.path.join("#", "library", "jsoncpp-src-*")),
        Glob(os.path.join("#", "library", "hdf*")),
        Glob(os.path.join("#", "library", "cln*")),
        Glob(os.path.join("#", "library", "ginac*")),
        Glob(os.path.join("#", "library", "libxml2*")),
        Glob(os.path.join("#", "library", "atlas*")),
        os.path.join("#", "library", "ATLAS")
    ]
) 






"""
skiplist = str(env["skipbuild"]).split(",")
if ("librarybuild" in COMMAND_LINE_TARGETS) and ("all" in skiplist) :
    raise RuntimeError("nothing to build")

#build into a temp dir
lst = []
lst.append( env.Command("mkbuilddir", "", Mkdir(os.path.join(workingpath, "build"))) )


#clear install directories before compiling
lst.append( env.Command("cleanbeforebuilddir", "", clearbuilddir) )

#download LAPack & ATLAS, extract & install
if not("atlas" in skiplist) :
    lst.append( env.Command("downloadlapackatlas", "", download_atlaslapack) )
    lst.append( env.Command("mkatlasbuilddir", "", Mkdir(os.path.join(workingpath, "atlasbuild"))) )
    lst.append( env.Command("buildatlaslapack", "", build_atlaslapack) )
    if env["TOOLKIT"] == "posix" or env["TOOLKIT"] == "cygwin" :
        lst.append( env.Command("sonameatlaslapack", "", soname_atlaslapack) )
    lst.append( env.Command("installatlaslapack", "", install_atlaslapack) )

# download Boost, extract & install
if not("boost" in skiplist) :
    lst.append( env.Command("downloadboost", "", download_boost) )
    if env["TOOLKIT"] == "cygwin" :
        lst.append( env.Command("extractzlib", "", "tar oxfvz "+os.path.join(workingpath, "zlib.tar.gz")+" -C library") )
        lst.append( env.Command("buildzlib", "", build_zlib) )
        lst.append( env.Command("extractbzip2", "", "tar oxfvz "+os.path.join(workingpath, "bzip2.tar.gz")+" -C library") )
        lst.append( env.Command("buildbzip2", "", build_bzip2) )
    lst.append( env.Command("extractboost", "", "tar oxfvj "+os.path.join(workingpath, "boost.tar.bz2")+" -C library") )
    lst.append( env.Command("buildboost", "", build_boost) )

# download HDF, extract & install
if not("hdf" in skiplist) :
    lst.append( env.Command("downloadhdf", "", download_hdf) )
    lst.append( env.Command("extracthdf", "", "tar oxfvj "+os.path.join(workingpath, "hdf.tar.bz2")+" -C library") )
    lst.append( env.Command("buildhdf", "", build_hdf) )

#download GiNaC & CLN, extract & install
if not("ginac" in skiplist) :
    lst.append( env.Command("downloadginaccln", "", download_ginaccln) )
    lst.append( env.Command("extractginac", "", "tar oxfvj "+os.path.join(workingpath, "ginac.tar.bz2")+" -C library") )
    lst.append( env.Command("extractcln", "", "tar oxfvj "+os.path.join(workingpath, "cln.tar.bz2")+" -C library") )
    lst.append( env.Command("buildginaccln", "", build_ginaccln) )

#download JSON library, extract & install
if not("json" in skiplist) :
    lst.append( env.Command("downloadjsoncpp", "", download_jsoncpp) )
    lst.append( env.Command("extractjsoncpp", "", "tar oxfvz "+os.path.join(workingpath, "jsoncpp.tar.gz")+" -C library") )
    lst.append( env.Command("buildjsoncpp", "", build_jsoncpp) )
    
# download libxml2, extract & install (only cygwin)
if env["TOOLKIT"] == "cygwin" and not("xml" in skiplist) :
    lst.append( env.Command("downloadxml", "", download_xml) )
    lst.append( env.Command("extractjsoncpp", "", "tar oxfvz "+os.path.join(workingpath, "xml.tar.gz")+" -C library") )
    lst.append( env.Command("buildxml", "", build_xml) )


#clear install directories after compiling
lst.append( env.Command("cleanafterbuilddir", "", clearbuilddir) )

#show the config path
lst.append( env.Command("showconfig", "", showconfig) )

env.Alias("librarybuild", lst)
"""