        l_target(0,0)  = -1.0891;       l_target(0,1)  = -1.4023;
        l_target(1,0)  = 0.0326;        l_target(1,1)  = -1.4224;
        l_target(2,0)  = 0.5525;        l_target(2,1)  = 0.4882;
        l_target(3,0)  = 1.1006;        l_target(3,1)  = -0.1774;
        l_target(4,0)  = 1.5442;        l_target(4,1)  = -0.1961;
        l_target(5,0)  = 0.0859;        l_target(5,1)  = 1.4193;
        l_target(6,0)  = -1.4916;       l_target(6,1)  = 0.2916;
        l_target(7,0)  = -0.7423;       l_target(7,1)  = 0.1978;
        l_target(8,0)  = -1.0616;       l_target(8,1)  = 1.5877;
        l_target(9,0)  = 2.3505;        l_target(9,1)  = -0.8045;
        l_target(10,0) = -0.6156;       l_target(10,1) = 0.6966;
        l_target(11,0) = 0.7481;        l_target(11,1) = 0.8351;
        l_target(12,0) = -0.1924;       l_target(12,1) = -0.2437;
        l_target(13,0) = 0.8886;        l_target(13,1) = 0.2157;
        l_target(14,0) = -0.7648;       l_target(14,1) = -1.1658;




        m_prototypes(0,0)  = 0.4909;     m_prototypes(0,1)  = 0.1320;
        m_prototypes(1,0)  = 0.4893;     m_prototypes(1,1)  = 0.9421;
        m_prototypes(2,0)  = 0.3377;     m_prototypes(2,1)  = 0.9561;
        //m_prototypes(3,0)  = 0.9001;     m_prototypes(3,1)  = 0.5752;
        //m_prototypes(4,0)  = 0.3692;     m_prototypes(4,1)  = 0.0598;
        //m_prototypes(5,0)  = 0.1112;     m_prototypes(5,1)  = 0.2348;
        //m_prototypes(6,0)  = 0.7803;     m_prototypes(6,1)  = 0.3532;
        //m_prototypes(7,0)  = 0.3897;     m_prototypes(7,1)  = 0.8212;
        //m_prototypes(8,0)  = 0.2417;     m_prototypes(8,1)  = 0.0154;
        //m_prototypes(9,0)  = 0.4039;     m_prototypes(9,1)  = 0.0430;
        //m_prototypes(10,0) = 0.0965;     m_prototypes(10,1) = 0.1690;

        
        m_prototypes(0,0) = 0.1062;    m_prototypes(0,1) = 0.3395;
        m_prototypes(1,0) = 0.3724;    m_prototypes(1,1) = 0.9516;
        m_prototypes(2,0) = 0.1981;    m_prototypes(2,1) = 0.9203;
        m_prototypes(3,0) = 0.4897;    m_prototypes(3,1) = 0.0527;



    inline void twitter::printValueTree( Json::Value &value, const std::string &path ) const
    {
        switch ( value.type() ) {
            
            case Json::nullValue:
                printf("%s=null\n", path.c_str() );
                break;
            
            case Json::intValue:
                printf("%s=%d\n", path.c_str(), value.asInt() );
                break;
            
            case Json::uintValue:
                printf("%s=%u\n", path.c_str(), value.asUInt() );
                break;
            
            case Json::realValue:
                printf("%s=%.16g\n", path.c_str(), value.asDouble() );
                break;
            
            case Json::stringValue:
                printf("%s=\"%s\"\n", path.c_str(), value.asString().c_str() );
                break;
            
            case Json::booleanValue:
                printf("%s=%s\n", path.c_str(), value.asBool() ? "true" : "false" );
                break;
                
            case Json::arrayValue:
                printf("%s=[]\n", path.c_str() );
                for ( unsigned int index =0; index < value.size(); ++index )
                {
                    static char buffer[16];
                    sprintf( buffer, "[%d]", index );
                    printValueTree(value[index], path + buffer );
                }
                break;
                
            case Json::objectValue:
                printf("%s={}\n", path.c_str() );
                Json::Value::Members members( value.getMemberNames() );
                std::sort( members.begin(), members.end() );
                std::string suffix = *(path.end()-1) == '.' ? "" : ".";
                for ( Json::Value::Members::iterator it = members.begin(); 
                     it != members.end(); 
                     ++it )
                {
                    const std::string &name = *it;
                    printValueTree(value[name], path + suffix + name );
                }
                break;
        }
    }



    
    // ===== Gradient ======
    /*
    boost::multi_array<double, 2> x;
    boost::multi_array<double, 2> y;
    boost::multi_array<double, 2> target;
    
    func::gradientdescent<double, 2> gd("a*x^3 + b*y^4");
    
    
    gd.setErrorFunction("a, b");
    
    gd.setOptimizeVar("a", 9);
    gd.setOptimizeVar("b", 2, 5);
    
    gd.setStaticVar("x", x);
    gd.setStaticVar("y", y);
    gd.setStaticVar("target", target);
    
    gd.optimize(1, 0.1);
    */
            
    // ==== LLE ====
    /*
    ublas::matrix<double> data = o.readMatrix<double>("/pcadata", H5::PredType::NATIVE_DOUBLE); 
    
    dist::euclid<double> d;
    nd::knn<double> k(d, 12);
    ndim::lle<double> l(k,2);
    
    tl::files::hdf f("lle.hdf5", true);
    f.write<double>( "/data",  l.map(data), H5::PredType::NATIVE_DOUBLE );  
    */
