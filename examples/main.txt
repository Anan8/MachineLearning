#include "../machinelearning.h"

#include <iostream>
#include <algorithm>
#include <fstream>
#include <map>

#include <boost/archive/text_oarchive.hpp>
#include <boost/archive/text_iarchive.hpp>

#include <boost/numeric/ublas/io.hpp>
#include <boost/thread.hpp> 

#include "boost/multi_array.hpp"
#include <boost/numeric/ublas/matrix.hpp>
#include <boost/numeric/ublas/matrix_sparse.hpp>
#include <boost/numeric/ublas/symmetric.hpp>
#include <boost/numeric/ublas/vector.hpp>
#include <boost/numeric/ublas/matrix_proxy.hpp>
#include <boost/numeric/ublas/vector_proxy.hpp>

#include <boost/numeric/bindings/ublas/matrix.hpp>
#include <boost/numeric/bindings/ublas/vector.hpp>

#ifdef ML_CLUSTER
#include <mpi.h>
#endif



namespace tl        = machinelearning::tools;
namespace dist      = machinelearning::distances;
namespace ndim      = machinelearning::dimensionreduce::nonsupervised;
namespace dim       = machinelearning::dimensionreduce::supervised;
namespace sl        = machinelearning::clustering::supervised;
namespace nsl       = machinelearning::clustering::nonsupervised;
namespace nd        = machinelearning::neighborhood;
namespace cl        = machinelearning::classifier;
namespace func      = machinelearning::functionaloptimization;
namespace linalg    = boost::numeric::bindings::lapack;
namespace ublas     = boost::numeric::ublas;
#ifdef ML_CLUSTER
namespace mpi	= boost::mpi;
#endif



int main(int argc, char* argv[]) {


    inline void twitter::printValueTree( Json::Value &value, const std::string &path ) const
    {
        switch ( value.type() ) {
            
            case Json::nullValue:
                printf("%s=null\n", path.c_str() );
                break;
            
            case Json::intValue:
                printf("%s=%d\n", path.c_str(), value.asInt() );
                break;
            
            case Json::uintValue:
                printf("%s=%u\n", path.c_str(), value.asUInt() );
                break;
            
            case Json::realValue:
                printf("%s=%.16g\n", path.c_str(), value.asDouble() );
                break;
            
            case Json::stringValue:
                printf("%s=\"%s\"\n", path.c_str(), value.asString().c_str() );
                break;
            
            case Json::booleanValue:
                printf("%s=%s\n", path.c_str(), value.asBool() ? "true" : "false" );
                break;
                
            case Json::arrayValue:
                printf("%s=[]\n", path.c_str() );
                for ( unsigned int index =0; index < value.size(); ++index )
                {
                    static char buffer[16];
                    sprintf( buffer, "[%d]", index );
                    printValueTree(value[index], path + buffer );
                }
                break;
                
            case Json::objectValue:
                printf("%s={}\n", path.c_str() );
                Json::Value::Members members( value.getMemberNames() );
                std::sort( members.begin(), members.end() );
                std::string suffix = *(path.end()-1) == '.' ? "" : ".";
                for ( Json::Value::Members::iterator it = members.begin(); 
                     it != members.end(); 
                     ++it )
                {
                    const std::string &name = *it;
                    printValueTree(value[name], path + suffix + name );
                }
                break;
        }
    }



    #ifdef ML_CLUSTER
    mpi::environment loMPIenv(argc, argv);
    //MPI::Init_thread( argc, argv, MPI_THREAD_SERIALIZED );
    mpi::communicator loMPICom;
    //tl::logger::getInstance()->startListener(loMPICom);
    #endif
    
    //tl::logger::getInstance()->setLevel( tl::logger::info );
    
    
    #ifdef ML_MULTILANGUAGE
    tl::language::bind("ml", "./tools/language/");
    #endif
    
    #ifdef ML_FILES
    tl::files::hdf o("blub.hdf5");
    /*tl::files::hdf o("string.hdf5");
    std::vector<std::string> x = o.readStringVector("/array");
    for(std::size_t i=0; i < x.size(); ++i)
        std::cout << x[i] << std::endl;*/    
    #endif
    
    //tl::logger::getInstance()->write(loMPICom, tl::logger::warn, "ich teste alles");
    
    
    // ===== Gradient ======
    /*
    boost::multi_array<double, 2> x;
    boost::multi_array<double, 2> y;
    boost::multi_array<double, 2> target;
    
    func::gradientdescent<double, 2> gd("a*x^3 + b*y^4");
    
    
    gd.setErrorFunction("a, b");
    
    gd.setOptimizeVar("a", 9);
    gd.setOptimizeVar("b", 2, 5);
    
    gd.setStaticVar("x", x);
    gd.setStaticVar("y", y);
    gd.setStaticVar("target", target);
    
    gd.optimize(1, 0.1);
    */
            
    // ==== LLE ====
    /*
    ublas::matrix<double> data = o.readMatrix<double>("/pcadata", H5::PredType::NATIVE_DOUBLE); 
    
    dist::euclid<double> d;
    nd::knn<double> k(d, 12);
    ndim::lle<double> l(k,2);
    
    tl::files::hdf f("lle.hdf5", true);
    f.write<double>( "/data",  l.map(data), H5::PredType::NATIVE_DOUBLE );  
    */
    
    return EXIT_SUCCESS;
}
